using System.Collections.Immutable;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Thaum.Prompts.Generator;

[Generator(LanguageNames.CSharp)]
public sealed class PromptGenerator : IIncrementalGenerator {
	private static readonly Regex TemplateVarPattern = new(@"\{(\w+)\}", RegexOptions.Compiled);

	public void Initialize(IncrementalGeneratorInitializationContext context) {
		var promptFiles = context.AdditionalTextsProvider
			.Where(static file => file.Path.Contains("prompts/") && file.Path.EndsWith(".txt"))
			.Select(static (file, ct) => new PromptFile(
				Path.GetFileNameWithoutExtension(file.Path),
				file.GetText(ct)?.ToString() ?? ""));

		var collected = promptFiles.Collect();

		context.RegisterSourceOutput(collected, static (context, prompts) => {
			GeneratePromptClasses(context, prompts);
			if (prompts.Length > 0) {
				GeneratePromptRegistry(context, prompts);
			}
		});
	}

	private static void GeneratePromptClasses(SourceProductionContext context, ImmutableArray<PromptFile> prompts) {
		foreach (var prompt in prompts) {
			var className = ToPascalCase(prompt.Name);
			var templateVars = ExtractTemplateVariables(prompt.Content);
			var source = GeneratePromptFunction(className, prompt.Content, templateVars);
			context.AddSource($"{className}.g.cs", SourceText.From(source, Encoding.UTF8));
		}
	}

	private static void GeneratePromptRegistry(SourceProductionContext context, ImmutableArray<PromptFile> prompts) {
		var allPromptNames = string.Join(", ", prompts.Select(p => $"\"{p.Name}\""));
		var functionMappings = string.Join("\n\t\t", prompts.Select(p => {
			var functionName = ToCamelCase(ToPascalCase(p.Name));
			return $"\"{p.Name}\" => \"{functionName}\",";
		}));

		var source = string.Format(RegistryTemplate, allPromptNames, functionMappings);
		context.AddSource("PromptRegistry.g.cs", SourceText.From(source, Encoding.UTF8));
	}

	private static string GeneratePromptFunction(string className, string content, HashSet<string> templateVars) {
		var escapedContent = content.Replace("\"", "\"\"");
		var functionName = ToCamelCase(className);
		var parameters = string.Join(", ", templateVars.Select(var => $"string {ToCamelCase(var)}"));
		var replacements = string.Join("\n\t\t\t", templateVars.Select(var =>
			$".Replace(\"{{{var}}}\", {ToCamelCase(var)})"));

		return string.Format(FunctionTemplate, functionName, parameters, className, escapedContent, replacements);
	}

	private static HashSet<string> ExtractTemplateVariables(string content) {
		var matches = TemplateVarPattern.Matches(content);
		return matches.Select(static m => m.Groups[1].Value).ToHashSet();
	}

	private static string ToPascalCase(string input) {
		return string.Join("", input.Split('_')
			.Select(static part => char.ToUpperInvariant(part[0]) + part[1..].ToLowerInvariant()));
	}

	private static string ToCamelCase(string input) {
		var pascal = ToPascalCase(input);
		return pascal.Length > 0 ? char.ToLowerInvariant(pascal[0]) + pascal[1..] : pascal;
	}

	private const string FunctionTemplate = """
		// <auto-generated />
		#nullable enable

		namespace Thaum.Prompts;

		public static partial class Prompts {{
			private const string {2}Template = @"{3}";

			public static string {0}({1}) {{
				return {2}Template
					{4};
			}}
		}}
		""";

	private const string RegistryTemplate = """
		// <auto-generated />
		#nullable enable

		namespace Thaum.Prompts;

		public static class PromptRegistry {{
			public static readonly string[] AllPromptNames = [{0}];

			public static string GetFunctionName(string promptName) => promptName switch {{
				{1}
				_ => throw new ArgumentException($"Unknown prompt: {{promptName}}", nameof(promptName))
			}};
		}}
		""";

	private record PromptFile(string Name, string Content);
}