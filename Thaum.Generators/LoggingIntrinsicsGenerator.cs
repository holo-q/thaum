using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Thaum.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class LoggingIntrinsicsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Provide the attribute source
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "LoggingIntrinsicsAttribute.g.cs",
            SourceText.From(AttributeSource, Encoding.UTF8)));

        // Find classes with [LoggingIntrinsics]
        var candidates = context.SyntaxProvider
            .CreateSyntaxProvider(
                (node, _) => node is ClassDeclarationSyntax cds && HasAttribute(cds),
                (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
            .Where(c => c is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(candidates.Collect());

        context.RegisterSourceOutput(compilationAndClasses, (spc, tuple) =>
        {
            var (compilation, classes) = tuple;
            foreach (var cls in classes.Distinct())
            {
                try { GenerateFor(spc, compilation, cls); }
                catch { /* be resilient */ }
            }
        });
    }

    private static void GenerateFor(SourceProductionContext spc, Compilation compilation, ClassDeclarationSyntax cls)
    {
        var model = compilation.GetSemanticModel(cls.SyntaxTree);
        var symbol = model.GetDeclaredSymbol(cls) as INamedTypeSymbol;
        if (symbol is null) return;

        // Must be partial
        if (!cls.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
        {
            var diag = Diagnostic.Create(
                new DiagnosticDescriptor("THAUM001", "Class must be partial",
                    "Class '{0}' marked with [LoggingIntrinsics] must be declared partial",
                    "Thaum.Generators", DiagnosticSeverity.Error, true),
                cls.Identifier.GetLocation(), symbol.Name);
            spc.ReportDiagnostic(diag);
            return;
        }

        string ns = symbol.ContainingNamespace.IsGlobalNamespace ? "" : symbol.ContainingNamespace.ToDisplayString();
        string typeName = symbol.Name;
        string typeParams = symbol.TypeParameters.Length > 0 ? "<" + string.Join(",", symbol.TypeParameters.Select(tp => tp.Name)) + ">" : string.Empty;
        string typeConstraints = BuildConstraints(symbol);

        // Check if the class is static
        bool isStaticClass = cls.Modifiers.Any(m => m.IsKind(SyntaxKind.StaticKeyword));
        string methodVisibility = isStaticClass ? "private static" : "protected";
        string instanceMethodVisibility = isStaticClass ? "private static" : "protected";

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        if (!string.IsNullOrEmpty(ns)) { sb.Append("namespace ").Append(ns).AppendLine(";"); }
        sb.AppendLine("using Microsoft.Extensions.Logging;");
        sb.Append("partial class ").Append(typeName).Append(typeParams).AppendLine();
        if (!string.IsNullOrEmpty(typeConstraints)) sb.AppendLine(typeConstraints);
        sb.AppendLine("{");
        // Logger field
        if (isStaticClass)
        {
            sb.Append("    private static readonly global::Microsoft.Extensions.Logging.ILogger __log = global::Thaum.Core.Utils.Logging.Get(\"")
              .Append(typeName).AppendLine("\");");
        }
        else
        {
            sb.Append("    private static readonly global::Microsoft.Extensions.Logging.ILogger __log = global::Thaum.Core.Utils.Logging.Get<")
              .Append(typeName).Append(typeParams).AppendLine(">();");
        }

        if (isStaticClass)
        {
            // Static helpers (for static classes only)
            sb.AppendLine($"    {methodVisibility} void trace(string message, params object?[] args) => __log.LogTrace(message, args);");
            sb.AppendLine($"    {methodVisibility} void info(string message, params object?[] args) => __log.LogInformation(message, args);");
            sb.AppendLine($"    {methodVisibility} void warn(string message, params object?[] args) => __log.LogWarning(message, args);");
            sb.AppendLine($"    {methodVisibility} void err(string message, params object?[] args) => __log.LogError(message, args);");
            sb.AppendLine($"    {methodVisibility} void err(System.Exception ex, string message, params object?[] args) => __log.LogError(ex, message, args);");
            sb.AppendLine($"    {methodVisibility} void print(object? value = null) => __log.LogInformation(value is null ? \"\" : value.ToString());");
            sb.AppendLine($"    {methodVisibility} void println(object? value = null) => __log.LogInformation(value is null ? \"\" : value.ToString());");
            sb.AppendLine($"    {methodVisibility} void assert(bool condition, string? message = null) {{ if (!condition) __log.LogError(message ?? \"Assertion failed\"); }}");
        }
        else
        {
            // Instance helpers (for non-static classes)
            sb.AppendLine($"    {instanceMethodVisibility} void trace(string message, params object?[] args) => __log.LogTrace(message, args);");
            sb.AppendLine($"    {instanceMethodVisibility} void info(string message, params object?[] args) => __log.LogInformation(message, args);");
            sb.AppendLine($"    {instanceMethodVisibility} void warn(string message, params object?[] args) => __log.LogWarning(message, args);");
            sb.AppendLine($"    {instanceMethodVisibility} void err(string message, params object?[] args) => __log.LogError(message, args);");
            sb.AppendLine($"    {instanceMethodVisibility} void err(System.Exception ex, string message, params object?[] args) => __log.LogError(ex, message, args);");
            sb.AppendLine($"    {instanceMethodVisibility} void print(object? value = null) => __log.LogInformation(value is null ? \"\" : value.ToString());");
            sb.AppendLine($"    {instanceMethodVisibility} void println(object? value = null) => __log.LogInformation(value is null ? \"\" : value.ToString());");
            sb.AppendLine($"    {instanceMethodVisibility} void assert(bool condition, string? message = null) {{ if (!condition) __log.LogError(message ?? \"Assertion failed\"); }}");
        }

        sb.AppendLine("}");

        string hint = $"{symbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat).Replace('<','_').Replace('>','_')}.LoggingIntrinsics.g.cs";
        spc.AddSource(hint, SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static bool HasAttribute(ClassDeclarationSyntax cds)
        => cds.AttributeLists.SelectMany(a => a.Attributes).Any(a => a.Name.ToString().Contains("LoggingIntrinsics"));

    private static string BuildConstraints(INamedTypeSymbol symbol)
    {
        if (symbol.TypeParameters.Length == 0) return string.Empty;
        var parts = new List<string>();
        foreach (var tp in symbol.TypeParameters)
        {
            var cons = new List<string>();
            foreach (var c in tp.ConstraintTypes)
            {
                cons.Add(c.ToDisplayString());
            }
            if (tp.HasConstructorConstraint) cons.Add("new()");
            if (tp.HasNotNullConstraint) cons.Add("notnull");
            if (tp.HasUnmanagedTypeConstraint) cons.Add("unmanaged");
            if (tp.HasReferenceTypeConstraint) cons.Add("class");
            if (tp.HasValueTypeConstraint) cons.Add("struct");
            if (cons.Count > 0)
                parts.Add($"where {tp.Name} : {string.Join(", ", cons)}");
        }
        return string.Join(" ", parts);
    }

    private const string AttributeSource = @"// <auto-generated>
namespace Thaum.Meta {
    [System.AttributeUsage(System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    internal sealed class LoggingIntrinsicsAttribute : System.Attribute { }
}
";
}
